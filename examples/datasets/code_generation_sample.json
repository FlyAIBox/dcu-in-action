[
  {
    "instruction": "编写一个Python函数计算斐波那契数列",
    "input": "请编写一个函数，输入n，返回斐波那契数列的第n项",
    "output": "```python\ndef fibonacci(n):\n    \"\"\"\n    计算斐波那契数列的第n项\n    \n    Args:\n        n (int): 序列位置，从0开始\n    \n    Returns:\n        int: 第n项的值\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for i in range(2, n + 1):\n            a, b = b, a + b\n        return b\n\n# 测试示例\nprint(fibonacci(10))  # 输出: 55\n```"
  },
  {
    "instruction": "实现一个二分查找算法",
    "input": "在有序数组中查找目标值的位置",
    "output": "```python\ndef binary_search(arr, target):\n    \"\"\"\n    在有序数组中使用二分查找算法查找目标值\n    \n    Args:\n        arr (list): 有序数组\n        target: 要查找的目标值\n    \n    Returns:\n        int: 目标值的索引，如果不存在返回-1\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\n# 测试示例\narr = [1, 3, 5, 7, 9, 11, 13, 15]\nresult = binary_search(arr, 7)\nprint(f\"目标值7的位置: {result}\")  # 输出: 目标值7的位置: 3\n```"
  },
  {
    "instruction": "创建一个简单的REST API",
    "input": "使用Flask创建一个用户管理的REST API",
    "output": "```python\nfrom flask import Flask, request, jsonify\nfrom datetime import datetime\n\napp = Flask(__name__)\n\n# 内存中的用户数据\nusers = [\n    {\"id\": 1, \"name\": \"张三\", \"email\": \"zhangsan@example.com\", \"created_at\": \"2024-01-01\"},\n    {\"id\": 2, \"name\": \"李四\", \"email\": \"lisi@example.com\", \"created_at\": \"2024-01-02\"}\n]\n\nnext_id = 3\n\n@app.route('/api/users', methods=['GET'])\ndef get_users():\n    \"\"\"获取所有用户\"\"\"\n    return jsonify({\"users\": users, \"total\": len(users)})\n\n@app.route('/api/users/<int:user_id>', methods=['GET'])\ndef get_user(user_id):\n    \"\"\"获取单个用户\"\"\"\n    user = next((u for u in users if u['id'] == user_id), None)\n    if user:\n        return jsonify(user)\n    return jsonify({\"error\": \"用户不存在\"}), 404\n\n@app.route('/api/users', methods=['POST'])\ndef create_user():\n    \"\"\"创建新用户\"\"\"\n    global next_id\n    data = request.json\n    \n    # 验证必要字段\n    if not data or 'name' not in data or 'email' not in data:\n        return jsonify({\"error\": \"缺少必要字段\"}), 400\n    \n    new_user = {\n        \"id\": next_id,\n        \"name\": data['name'],\n        \"email\": data['email'],\n        \"created_at\": datetime.now().strftime('%Y-%m-%d')\n    }\n    \n    users.append(new_user)\n    next_id += 1\n    \n    return jsonify(new_user), 201\n\n@app.route('/api/users/<int:user_id>', methods=['PUT'])\ndef update_user(user_id):\n    \"\"\"更新用户信息\"\"\"\n    user = next((u for u in users if u['id'] == user_id), None)\n    if not user:\n        return jsonify({\"error\": \"用户不存在\"}), 404\n    \n    data = request.json\n    if 'name' in data:\n        user['name'] = data['name']\n    if 'email' in data:\n        user['email'] = data['email']\n    \n    return jsonify(user)\n\n@app.route('/api/users/<int:user_id>', methods=['DELETE'])\ndef delete_user(user_id):\n    \"\"\"删除用户\"\"\"\n    global users\n    users = [u for u in users if u['id'] != user_id]\n    return jsonify({\"message\": \"用户已删除\"})\n\nif __name__ == '__main__':\n    app.run(debug=True, host='0.0.0.0', port=5000)\n```"
  },
  {
    "instruction": "实现一个数据库连接类",
    "input": "创建一个MySQL数据库连接管理类",
    "output": "```python\nimport mysql.connector\nfrom mysql.connector import Error\nfrom contextlib import contextmanager\nimport logging\n\nclass DatabaseManager:\n    \"\"\"MySQL数据库连接管理类\"\"\"\n    \n    def __init__(self, host, port, database, username, password):\n        self.host = host\n        self.port = port\n        self.database = database\n        self.username = username\n        self.password = password\n        self.connection = None\n        \n        # 设置日志\n        logging.basicConfig(level=logging.INFO)\n        self.logger = logging.getLogger(__name__)\n    \n    def connect(self):\n        \"\"\"建立数据库连接\"\"\"\n        try:\n            self.connection = mysql.connector.connect(\n                host=self.host,\n                port=self.port,\n                database=self.database,\n                user=self.username,\n                password=self.password,\n                autocommit=False\n            )\n            \n            if self.connection.is_connected():\n                self.logger.info(f\"成功连接到数据库 {self.database}\")\n                return True\n                \n        except Error as e:\n            self.logger.error(f\"数据库连接失败: {e}\")\n            return False\n    \n    def disconnect(self):\n        \"\"\"关闭数据库连接\"\"\"\n        if self.connection and self.connection.is_connected():\n            self.connection.close()\n            self.logger.info(\"数据库连接已关闭\")\n    \n    @contextmanager\n    def get_cursor(self):\n        \"\"\"获取数据库游标的上下文管理器\"\"\"\n        cursor = None\n        try:\n            if not self.connection or not self.connection.is_connected():\n                self.connect()\n            \n            cursor = self.connection.cursor(dictionary=True)\n            yield cursor\n            \n        except Error as e:\n            self.logger.error(f\"数据库操作错误: {e}\")\n            if self.connection:\n                self.connection.rollback()\n            raise\n        finally:\n            if cursor:\n                cursor.close()\n    \n    def execute_query(self, query, params=None):\n        \"\"\"执行查询语句\"\"\"\n        with self.get_cursor() as cursor:\n            cursor.execute(query, params or ())\n            return cursor.fetchall()\n    \n    def execute_update(self, query, params=None):\n        \"\"\"执行更新语句\"\"\"\n        with self.get_cursor() as cursor:\n            cursor.execute(query, params or ())\n            self.connection.commit()\n            return cursor.rowcount\n    \n    def execute_many(self, query, data_list):\n        \"\"\"批量执行语句\"\"\"\n        with self.get_cursor() as cursor:\n            cursor.executemany(query, data_list)\n            self.connection.commit()\n            return cursor.rowcount\n\n# 使用示例\nif __name__ == \"__main__\":\n    # 创建数据库管理器实例\n    db = DatabaseManager(\n        host=\"localhost\",\n        port=3306,\n        database=\"test_db\",\n        username=\"root\",\n        password=\"password\"\n    )\n    \n    try:\n        # 查询示例\n        users = db.execute_query(\"SELECT * FROM users WHERE age > %s\", (25,))\n        print(f\"查询结果: {users}\")\n        \n        # 更新示例\n        affected_rows = db.execute_update(\n            \"UPDATE users SET email = %s WHERE id = %s\",\n            (\"newemail@example.com\", 1)\n        )\n        print(f\"更新了 {affected_rows} 行\")\n        \n    finally:\n        db.disconnect()\n```"
  },
  {
    "instruction": "实现一个简单的机器学习分类器",
    "input": "使用scikit-learn创建一个文本分类器",
    "output": "```python\nimport pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import classification_report, confusion_matrix\nfrom sklearn.pipeline import Pipeline\nimport joblib\n\nclass TextClassifier:\n    \"\"\"文本分类器类\"\"\"\n    \n    def __init__(self):\n        self.pipeline = Pipeline([\n            ('tfidf', TfidfVectorizer(\n                max_features=10000,\n                ngram_range=(1, 2),\n                stop_words='english',\n                lowercase=True\n            )),\n            ('classifier', LogisticRegression(\n                random_state=42,\n                max_iter=1000\n            ))\n        ])\n        \n        self.is_trained = False\n    \n    def prepare_data(self, texts, labels):\n        \"\"\"准备训练数据\"\"\"\n        # 数据清洗\n        texts = [str(text).strip() for text in texts]\n        \n        # 分割训练集和测试集\n        X_train, X_test, y_train, y_test = train_test_split(\n            texts, labels, \n            test_size=0.2, \n            random_state=42, \n            stratify=labels\n        )\n        \n        return X_train, X_test, y_train, y_test\n    \n    def train(self, X_train, y_train):\n        \"\"\"训练模型\"\"\"\n        print(\"开始训练文本分类器...\")\n        \n        self.pipeline.fit(X_train, y_train)\n        self.is_trained = True\n        \n        print(\"模型训练完成！\")\n    \n    def evaluate(self, X_test, y_test):\n        \"\"\"评估模型性能\"\"\"\n        if not self.is_trained:\n            raise ValueError(\"模型尚未训练，请先调用train()方法\")\n        \n        # 预测\n        y_pred = self.pipeline.predict(X_test)\n        \n        # 计算准确率\n        accuracy = self.pipeline.score(X_test, y_test)\n        \n        # 详细报告\n        report = classification_report(y_test, y_pred)\n        \n        # 混淆矩阵\n        cm = confusion_matrix(y_test, y_pred)\n        \n        return {\n            'accuracy': accuracy,\n            'predictions': y_pred,\n            'classification_report': report,\n            'confusion_matrix': cm\n        }\n    \n    def predict(self, texts):\n        \"\"\"对新文本进行预测\"\"\"\n        if not self.is_trained:\n            raise ValueError(\"模型尚未训练，请先调用train()方法\")\n        \n        if isinstance(texts, str):\n            texts = [texts]\n        \n        predictions = self.pipeline.predict(texts)\n        probabilities = self.pipeline.predict_proba(texts)\n        \n        return predictions, probabilities\n    \n    def save_model(self, filepath):\n        \"\"\"保存模型\"\"\"\n        if not self.is_trained:\n            raise ValueError(\"模型尚未训练，无法保存\")\n        \n        joblib.dump(self.pipeline, filepath)\n        print(f\"模型已保存到: {filepath}\")\n    \n    def load_model(self, filepath):\n        \"\"\"加载模型\"\"\"\n        self.pipeline = joblib.load(filepath)\n        self.is_trained = True\n        print(f\"模型已从 {filepath} 加载\")\n\n# 使用示例\nif __name__ == \"__main__\":\n    # 示例数据\n    sample_texts = [\n        \"这部电影真的很棒，演员表演出色\",\n        \"电影太无聊了，浪费时间\",\n        \"剧情很有趣，值得推荐\",\n        \"画面质量差，音效也不好\",\n        \"这是我看过最好的电影之一\"\n    ]\n    \n    sample_labels = [\"positive\", \"negative\", \"positive\", \"negative\", \"positive\"]\n    \n    # 创建分类器\n    classifier = TextClassifier()\n    \n    # 准备数据\n    X_train, X_test, y_train, y_test = classifier.prepare_data(\n        sample_texts, sample_labels\n    )\n    \n    # 训练模型\n    classifier.train(X_train, y_train)\n    \n    # 预测新文本\n    new_texts = [\"这个电影很精彩\", \"太糟糕了\"]\n    predictions, probabilities = classifier.predict(new_texts)\n    \n    for text, pred, prob in zip(new_texts, predictions, probabilities):\n        print(f\"文本: {text}\")\n        print(f\"预测: {pred}\")\n        print(f\"概率: {prob}\\n\")\n```"
  }
] 